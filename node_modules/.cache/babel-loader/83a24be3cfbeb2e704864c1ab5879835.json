{"ast":null,"code":"import _classCallCheck from \"/Users/Junhaeng/untitled folder/junior-design/amplifyapp/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/Junhaeng/untitled folder/junior-design/amplifyapp/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/* eslint-enable complexity, no-redeclare, no-var, one-var */\n\nimport FFT from './fft';\n\n/**\n * @typedef {Object} SpectrogramPluginParams\n * @property {string|HTMLElement} container Selector of element or element in\n * which to render\n * @property {number} fftSamples=512 Number of samples to fetch to FFT. Must be\n * a power of 2.\n * @property {boolean} splitChannels=false Render with separate spectrograms for\n * the channels of the audio\n * @property {number} height=fftSamples/2 Height of the spectrogram view in CSS\n * pixels\n * @property {boolean} labels Set to true to display frequency labels.\n * @property {number} noverlap Size of the overlapping window. Must be <\n * fftSamples. Auto deduced from canvas size by default.\n * @property {string} windowFunc='hann' The window function to be used. One of\n * these: `'bartlett'`, `'bartlettHann'`, `'blackman'`, `'cosine'`, `'gauss'`,\n * `'hamming'`, `'hann'`, `'lanczoz'`, `'rectangular'`, `'triangular'`\n * @property {?number} alpha Some window functions have this extra value.\n * (Between 0 and 1)\n * @property {number} pixelRatio=wavesurfer.params.pixelRatio to control the\n * size of the spectrogram in relation with its canvas. 1 = Draw on the whole\n * canvas. 2 = Draw on a quarter (1/2 the length and 1/2 the width)\n * @property {number} frequencyMin=0 Min frequency to scale spectrogram.\n * @property {number} frequencyMax=12000 Max frequency to scale spectrogram.\n * Set this to samplerate/2 to draw whole range of spectrogram.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('spectrogram')`\n * @property {?number[][]} colorMap A 256 long array of 4-element arrays.\n * Each entry should contain a float between 0 and 1 and specify\n * r, g, b, and alpha.\n */\n\n/**\n * Render a spectrogram visualisation of the audio.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import SpectrogramPlugin from 'wavesurfer.spectrogram.js';\n *\n * // commonjs\n * var SpectrogramPlugin = require('wavesurfer.spectrogram.js');\n *\n * // if you are using <script> tags\n * var SpectrogramPlugin = window.WaveSurfer.spectrogram;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     SpectrogramPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nvar SpectrogramPlugin = /*#__PURE__*/function () {\n  function SpectrogramPlugin(params, ws) {\n    var _this = this;\n    _classCallCheck(this, SpectrogramPlugin);\n    this.params = params;\n    this.wavesurfer = ws;\n    this.util = ws.util;\n    this.frequenciesDataUrl = params.frequenciesDataUrl;\n    this._onScroll = function (e) {\n      _this.updateScroll(e);\n    };\n    this._onRender = function () {\n      _this.render();\n    };\n    this._onWrapperClick = function (e) {\n      _this._wrapperClickHandler(e);\n    };\n    this._onReady = function () {\n      var drawer = _this.drawer = ws.drawer;\n      _this.container = 'string' == typeof params.container ? document.querySelector(params.container) : params.container;\n      if (!_this.container) {\n        throw Error('No container for WaveSurfer spectrogram');\n      }\n      if (params.colorMap) {\n        if (params.colorMap.length < 256) {\n          throw new Error('Colormap must contain 256 elements');\n        }\n        for (var i = 0; i < params.colorMap.length; i++) {\n          var cmEntry = params.colorMap[i];\n          if (cmEntry.length !== 4) {\n            throw new Error('ColorMap entries must contain 4 values');\n          }\n        }\n        _this.colorMap = params.colorMap;\n      } else {\n        _this.colorMap = [];\n        for (var _i = 0; _i < 256; _i++) {\n          var val = (255 - _i) / 256;\n          _this.colorMap.push([val, val, val, 1]);\n        }\n      }\n      _this.width = drawer.width;\n      _this.pixelRatio = _this.params.pixelRatio || ws.params.pixelRatio;\n      _this.fftSamples = _this.params.fftSamples || ws.params.fftSamples || 512;\n      _this.height = _this.params.height || _this.fftSamples / 2;\n      _this.noverlap = params.noverlap;\n      _this.windowFunc = params.windowFunc;\n      _this.alpha = params.alpha;\n      _this.splitChannels = params.splitChannels;\n      _this.channels = _this.splitChannels ? ws.backend.buffer.numberOfChannels : 1;\n\n      // Getting file's original samplerate is difficult(#1248).\n      // So set 12kHz default to render like wavesurfer.js 5.x.\n      _this.frequencyMin = params.frequencyMin || 0;\n      _this.frequencyMax = params.frequencyMax || 12000;\n      _this.createWrapper();\n      _this.createCanvas();\n      _this.render();\n      drawer.wrapper.addEventListener('scroll', _this._onScroll);\n      ws.on('redraw', _this._onRender);\n    };\n  }\n  _createClass(SpectrogramPlugin, [{\n    key: \"init\",\n    value: function init() {\n      // Check if wavesurfer is ready\n      if (this.wavesurfer.isReady) {\n        this._onReady();\n      } else {\n        this.wavesurfer.once('ready', this._onReady);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.unAll();\n      this.wavesurfer.un('ready', this._onReady);\n      this.wavesurfer.un('redraw', this._onRender);\n      this.drawer && this.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n      this.wavesurfer = null;\n      this.util = null;\n      this.params = null;\n      if (this.wrapper) {\n        this.wrapper.removeEventListener('click', this._onWrapperClick);\n        this.wrapper.parentNode.removeChild(this.wrapper);\n        this.wrapper = null;\n      }\n    }\n  }, {\n    key: \"createWrapper\",\n    value: function createWrapper() {\n      var prevSpectrogram = this.container.querySelector('spectrogram');\n      if (prevSpectrogram) {\n        this.container.removeChild(prevSpectrogram);\n      }\n      var wsParams = this.wavesurfer.params;\n      this.wrapper = document.createElement('spectrogram');\n      // if labels are active\n      if (this.params.labels) {\n        var labelsEl = this.labelsEl = document.createElement('canvas');\n        labelsEl.classList.add('spec-labels');\n        this.drawer.style(labelsEl, {\n          position: 'absolute',\n          zIndex: 9,\n          height: \"\".concat(this.height * this.channels, \"px\"),\n          width: \"55px\"\n        });\n        this.wrapper.appendChild(labelsEl);\n        this.loadLabels('rgba(68,68,68,0.5)', '12px', '10px', '', '#fff', '#f7f7f7', 'center', '#specLabels');\n      }\n      this.drawer.style(this.wrapper, {\n        display: 'block',\n        position: 'relative',\n        userSelect: 'none',\n        webkitUserSelect: 'none',\n        height: \"\".concat(this.height * this.channels, \"px\")\n      });\n      if (wsParams.fillParent || wsParams.scrollParent) {\n        this.drawer.style(this.wrapper, {\n          width: '100%',\n          overflowX: 'hidden',\n          overflowY: 'hidden'\n        });\n      }\n      this.container.appendChild(this.wrapper);\n      this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n  }, {\n    key: \"_wrapperClickHandler\",\n    value: function _wrapperClickHandler(event) {\n      event.preventDefault();\n      var relX = 'offsetX' in event ? event.offsetX : event.layerX;\n      this.fireEvent('click', relX / this.width || 0);\n    }\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas() {\n      var canvas = this.canvas = this.wrapper.appendChild(document.createElement('canvas'));\n      this.spectrCc = canvas.getContext('2d');\n      this.util.style(canvas, {\n        position: 'absolute',\n        zIndex: 4\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.updateCanvasStyle();\n      if (this.frequenciesDataUrl) {\n        this.loadFrequenciesData(this.frequenciesDataUrl);\n      } else {\n        this.getFrequencies(this.drawSpectrogram);\n      }\n    }\n  }, {\n    key: \"updateCanvasStyle\",\n    value: function updateCanvasStyle() {\n      var width = Math.round(this.width / this.pixelRatio) + 'px';\n      this.canvas.width = this.width;\n      this.canvas.height = this.fftSamples / 2 * this.channels;\n      this.canvas.style.width = width;\n      this.canvas.style.height = this.height + 'px';\n    }\n  }, {\n    key: \"drawSpectrogram\",\n    value: function drawSpectrogram(frequenciesData, my) {\n      if (!isNaN(frequenciesData[0][0])) {\n        // data is 1ch [sample, freq] format\n        // to [channel, sample, freq] format\n        frequenciesData = [frequenciesData];\n      }\n      var spectrCc = my.spectrCc;\n      var height = my.fftSamples / 2;\n      var width = my.width;\n      var freqFrom = my.buffer.sampleRate / 2;\n      var freqMin = my.frequencyMin;\n      var freqMax = my.frequencyMax;\n      if (!spectrCc) {\n        return;\n      }\n      var _loop = function _loop(c) {\n        // for each channel\n        var pixels = my.resample(frequenciesData[c]);\n        var imageData = new ImageData(width, height);\n        for (var i = 0; i < pixels.length; i++) {\n          for (var j = 0; j < pixels[i].length; j++) {\n            var colorMap = my.colorMap[pixels[i][j]];\n            var redIndex = ((height - j) * width + i) * 4;\n            imageData.data[redIndex] = colorMap[0] * 255;\n            imageData.data[redIndex + 1] = colorMap[1] * 255;\n            imageData.data[redIndex + 2] = colorMap[2] * 255;\n            imageData.data[redIndex + 3] = colorMap[3] * 255;\n          }\n        }\n\n        // scale and stack spectrograms\n        createImageBitmap(imageData).then(function (renderer) {\n          return spectrCc.drawImage(renderer, 0, height * (1 - freqMax / freqFrom),\n          // source x, y\n          width, height * (freqMax - freqMin) / freqFrom,\n          // source width, height\n          0, height * c,\n          // destination x, y\n          width, height // destination width, height\n          );\n        });\n      };\n      for (var c = 0; c < frequenciesData.length; c++) {\n        _loop(c);\n      }\n    }\n  }, {\n    key: \"getFrequencies\",\n    value: function getFrequencies(callback) {\n      var fftSamples = this.fftSamples;\n      var buffer = this.buffer = this.wavesurfer.backend.buffer;\n      var channels = this.channels;\n      if (!buffer) {\n        this.fireEvent('error', 'Web Audio buffer is not available');\n        return;\n      }\n\n      // This may differ from file samplerate. Browser resamples audio.\n      var sampleRate = buffer.sampleRate;\n      var frequencies = [];\n      var noverlap = this.noverlap;\n      if (!noverlap) {\n        var uniqueSamplesPerPx = buffer.length / this.canvas.width;\n        noverlap = Math.max(0, Math.round(fftSamples - uniqueSamplesPerPx));\n      }\n      var fft = new FFT(fftSamples, sampleRate, this.windowFunc, this.alpha);\n      for (var c = 0; c < channels; c++) {\n        // for each channel\n        var channelData = buffer.getChannelData(c);\n        var channelFreq = [];\n        var currentOffset = 0;\n        while (currentOffset + fftSamples < channelData.length) {\n          var segment = channelData.slice(currentOffset, currentOffset + fftSamples);\n          var spectrum = fft.calculateSpectrum(segment);\n          var array = new Uint8Array(fftSamples / 2);\n          var j = void 0;\n          for (j = 0; j < fftSamples / 2; j++) {\n            array[j] = Math.max(-255, Math.log10(spectrum[j]) * 45);\n          }\n          channelFreq.push(array);\n          // channelFreq: [sample, freq]\n\n          currentOffset += fftSamples - noverlap;\n        }\n        frequencies.push(channelFreq);\n        // frequencies: [channel, sample, freq]\n      }\n\n      callback(frequencies, this);\n    }\n  }, {\n    key: \"loadFrequenciesData\",\n    value: function loadFrequenciesData(url) {\n      var _this2 = this;\n      var request = this.util.fetchFile({\n        url: url\n      });\n      request.on('success', function (data) {\n        return _this2.drawSpectrogram(JSON.parse(data), _this2);\n      });\n      request.on('error', function (e) {\n        return _this2.fireEvent('error', e);\n      });\n      return request;\n    }\n  }, {\n    key: \"freqType\",\n    value: function freqType(freq) {\n      return freq >= 1000 ? (freq / 1000).toFixed(1) : Math.round(freq);\n    }\n  }, {\n    key: \"unitType\",\n    value: function unitType(freq) {\n      return freq >= 1000 ? 'KHz' : 'Hz';\n    }\n  }, {\n    key: \"loadLabels\",\n    value: function loadLabels(bgFill, fontSizeFreq, fontSizeUnit, fontType, textColorFreq, textColorUnit, textAlign, container) {\n      var frequenciesHeight = this.height;\n      bgFill = bgFill || 'rgba(68,68,68,0)';\n      fontSizeFreq = fontSizeFreq || '12px';\n      fontSizeUnit = fontSizeUnit || '10px';\n      fontType = fontType || 'Helvetica';\n      textColorFreq = textColorFreq || '#fff';\n      textColorUnit = textColorUnit || '#fff';\n      textAlign = textAlign || 'center';\n      container = container || '#specLabels';\n      var bgWidth = 55;\n      var getMaxY = frequenciesHeight || 512;\n      var labelIndex = 5 * (getMaxY / 256);\n      var freqStart = this.frequencyMin;\n      var step = (this.frequencyMax - freqStart) / labelIndex;\n\n      // prepare canvas element for labels\n      var ctx = this.labelsEl.getContext('2d');\n      var dispScale = window.devicePixelRatio;\n      this.labelsEl.height = this.height * this.channels * dispScale;\n      this.labelsEl.width = bgWidth * dispScale;\n      ctx.scale(dispScale, dispScale);\n      if (!ctx) {\n        return;\n      }\n      for (var c = 0; c < this.channels; c++) {\n        // for each channel\n        // fill background\n        ctx.fillStyle = bgFill;\n        ctx.fillRect(0, c * getMaxY, bgWidth, (1 + c) * getMaxY);\n        ctx.fill();\n        var i = void 0;\n\n        // render labels\n        for (i = 0; i <= labelIndex; i++) {\n          ctx.textAlign = textAlign;\n          ctx.textBaseline = 'middle';\n          var freq = freqStart + step * i;\n          var label = this.freqType(freq);\n          var units = this.unitType(freq);\n          var yLabelOffset = 2;\n          var x = 16;\n          var y = void 0;\n          if (i == 0) {\n            y = (1 + c) * getMaxY + i - 10;\n            // unit label\n            ctx.fillStyle = textColorUnit;\n            ctx.font = fontSizeUnit + ' ' + fontType;\n            ctx.fillText(units, x + 24, y);\n            // freq label\n            ctx.fillStyle = textColorFreq;\n            ctx.font = fontSizeFreq + ' ' + fontType;\n            ctx.fillText(label, x, y);\n          } else {\n            y = (1 + c) * getMaxY - i * 50 + yLabelOffset;\n            // unit label\n            ctx.fillStyle = textColorUnit;\n            ctx.font = fontSizeUnit + ' ' + fontType;\n            ctx.fillText(units, x + 24, y);\n            // freq label\n            ctx.fillStyle = textColorFreq;\n            ctx.font = fontSizeFreq + ' ' + fontType;\n            ctx.fillText(label, x, y);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"updateScroll\",\n    value: function updateScroll(e) {\n      if (this.wrapper) {\n        this.wrapper.scrollLeft = e.target.scrollLeft;\n      }\n    }\n  }, {\n    key: \"resample\",\n    value: function resample(oldMatrix) {\n      var columnsNumber = this.width;\n      var newMatrix = [];\n      var oldPiece = 1 / oldMatrix.length;\n      var newPiece = 1 / columnsNumber;\n      var i;\n      for (i = 0; i < columnsNumber; i++) {\n        var column = new Array(oldMatrix[0].length);\n        var j = void 0;\n        for (j = 0; j < oldMatrix.length; j++) {\n          var oldStart = j * oldPiece;\n          var oldEnd = oldStart + oldPiece;\n          var newStart = i * newPiece;\n          var newEnd = newStart + newPiece;\n          var overlap = oldEnd <= newStart || newEnd <= oldStart ? 0 : Math.min(Math.max(oldEnd, newStart), Math.max(newEnd, oldStart)) - Math.max(Math.min(oldEnd, newStart), Math.min(newEnd, oldStart));\n          var k = void 0;\n          /* eslint-disable max-depth */\n          if (overlap > 0) {\n            for (k = 0; k < oldMatrix[0].length; k++) {\n              if (column[k] == null) {\n                column[k] = 0;\n              }\n              column[k] += overlap / newPiece * oldMatrix[j][k];\n            }\n          }\n          /* eslint-enable max-depth */\n        }\n\n        var intColumn = new Uint8Array(oldMatrix[0].length);\n        var m = void 0;\n        for (m = 0; m < oldMatrix[0].length; m++) {\n          intColumn[m] = column[m];\n        }\n        newMatrix.push(intColumn);\n      }\n      return newMatrix;\n    }\n  }], [{\n    key: \"create\",\n    value:\n    /**\n     * Spectrogram plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {SpectrogramPluginParams} params Parameters used to initialise the plugin\n     * @return {PluginDefinition} An object representing the plugin.\n     */\n    function create(params) {\n      return {\n        name: 'spectrogram',\n        deferInit: params && params.deferInit ? params.deferInit : false,\n        params: params,\n        staticProps: {\n          FFT: FFT\n        },\n        instance: SpectrogramPlugin\n      };\n    }\n  }]);\n  return SpectrogramPlugin;\n}();\nexport { SpectrogramPlugin as default };","map":{"version":3,"names":["FFT","SpectrogramPlugin","params","ws","_this","_classCallCheck","wavesurfer","util","frequenciesDataUrl","_onScroll","e","updateScroll","_onRender","render","_onWrapperClick","_wrapperClickHandler","_onReady","drawer","container","document","querySelector","Error","colorMap","length","i","cmEntry","val","push","width","pixelRatio","fftSamples","height","noverlap","windowFunc","alpha","splitChannels","channels","backend","buffer","numberOfChannels","frequencyMin","frequencyMax","createWrapper","createCanvas","wrapper","addEventListener","on","_createClass","key","value","init","isReady","once","destroy","unAll","un","removeEventListener","parentNode","removeChild","prevSpectrogram","wsParams","createElement","labels","labelsEl","classList","add","style","position","zIndex","concat","appendChild","loadLabels","display","userSelect","webkitUserSelect","fillParent","scrollParent","overflowX","overflowY","event","preventDefault","relX","offsetX","layerX","fireEvent","canvas","spectrCc","getContext","updateCanvasStyle","loadFrequenciesData","getFrequencies","drawSpectrogram","Math","round","frequenciesData","my","isNaN","freqFrom","sampleRate","freqMin","freqMax","_loop","c","pixels","resample","imageData","ImageData","j","redIndex","data","createImageBitmap","then","renderer","drawImage","callback","frequencies","uniqueSamplesPerPx","max","fft","channelData","getChannelData","channelFreq","currentOffset","segment","slice","spectrum","calculateSpectrum","array","Uint8Array","log10","url","_this2","request","fetchFile","JSON","parse","freqType","freq","toFixed","unitType","bgFill","fontSizeFreq","fontSizeUnit","fontType","textColorFreq","textColorUnit","textAlign","frequenciesHeight","bgWidth","getMaxY","labelIndex","freqStart","step","ctx","dispScale","window","devicePixelRatio","scale","fillStyle","fillRect","fill","textBaseline","label","units","yLabelOffset","x","y","font","fillText","scrollLeft","target","oldMatrix","columnsNumber","newMatrix","oldPiece","newPiece","column","Array","oldStart","oldEnd","newStart","newEnd","overlap","min","k","intColumn","m","create","name","deferInit","staticProps","instance","default"],"sources":["/Users/Junhaeng/untitled folder/junior-design/amplifyapp/node_modules/wavesurfer.js/src/plugin/spectrogram/index.js"],"sourcesContent":["/* eslint-enable complexity, no-redeclare, no-var, one-var */\n\nimport FFT from './fft';\n\n/**\n * @typedef {Object} SpectrogramPluginParams\n * @property {string|HTMLElement} container Selector of element or element in\n * which to render\n * @property {number} fftSamples=512 Number of samples to fetch to FFT. Must be\n * a power of 2.\n * @property {boolean} splitChannels=false Render with separate spectrograms for\n * the channels of the audio\n * @property {number} height=fftSamples/2 Height of the spectrogram view in CSS\n * pixels\n * @property {boolean} labels Set to true to display frequency labels.\n * @property {number} noverlap Size of the overlapping window. Must be <\n * fftSamples. Auto deduced from canvas size by default.\n * @property {string} windowFunc='hann' The window function to be used. One of\n * these: `'bartlett'`, `'bartlettHann'`, `'blackman'`, `'cosine'`, `'gauss'`,\n * `'hamming'`, `'hann'`, `'lanczoz'`, `'rectangular'`, `'triangular'`\n * @property {?number} alpha Some window functions have this extra value.\n * (Between 0 and 1)\n * @property {number} pixelRatio=wavesurfer.params.pixelRatio to control the\n * size of the spectrogram in relation with its canvas. 1 = Draw on the whole\n * canvas. 2 = Draw on a quarter (1/2 the length and 1/2 the width)\n * @property {number} frequencyMin=0 Min frequency to scale spectrogram.\n * @property {number} frequencyMax=12000 Max frequency to scale spectrogram.\n * Set this to samplerate/2 to draw whole range of spectrogram.\n * @property {?boolean} deferInit Set to true to manually call\n * `initPlugin('spectrogram')`\n * @property {?number[][]} colorMap A 256 long array of 4-element arrays.\n * Each entry should contain a float between 0 and 1 and specify\n * r, g, b, and alpha.\n */\n\n/**\n * Render a spectrogram visualisation of the audio.\n *\n * @implements {PluginClass}\n * @extends {Observer}\n * @example\n * // es6\n * import SpectrogramPlugin from 'wavesurfer.spectrogram.js';\n *\n * // commonjs\n * var SpectrogramPlugin = require('wavesurfer.spectrogram.js');\n *\n * // if you are using <script> tags\n * var SpectrogramPlugin = window.WaveSurfer.spectrogram;\n *\n * // ... initialising wavesurfer with the plugin\n * var wavesurfer = WaveSurfer.create({\n *   // wavesurfer options ...\n *   plugins: [\n *     SpectrogramPlugin.create({\n *       // plugin options ...\n *     })\n *   ]\n * });\n */\nexport default class SpectrogramPlugin {\n    /**\n     * Spectrogram plugin definition factory\n     *\n     * This function must be used to create a plugin definition which can be\n     * used by wavesurfer to correctly instantiate the plugin.\n     *\n     * @param  {SpectrogramPluginParams} params Parameters used to initialise the plugin\n     * @return {PluginDefinition} An object representing the plugin.\n     */\n    static create(params) {\n        return {\n            name: 'spectrogram',\n            deferInit: params && params.deferInit ? params.deferInit : false,\n            params: params,\n            staticProps: {\n                FFT: FFT\n            },\n            instance: SpectrogramPlugin\n        };\n    }\n\n    constructor(params, ws) {\n        this.params = params;\n        this.wavesurfer = ws;\n        this.util = ws.util;\n\n        this.frequenciesDataUrl = params.frequenciesDataUrl;\n        this._onScroll = e => {\n            this.updateScroll(e);\n        };\n        this._onRender = () => {\n            this.render();\n        };\n        this._onWrapperClick = e => {\n            this._wrapperClickHandler(e);\n        };\n        this._onReady = () => {\n            const drawer = (this.drawer = ws.drawer);\n\n            this.container =\n                'string' == typeof params.container\n                    ? document.querySelector(params.container)\n                    : params.container;\n\n            if (!this.container) {\n                throw Error('No container for WaveSurfer spectrogram');\n            }\n            if (params.colorMap) {\n                if (params.colorMap.length < 256) {\n                    throw new Error('Colormap must contain 256 elements');\n                }\n                for (let i = 0; i < params.colorMap.length; i++) {\n                    const cmEntry = params.colorMap[i];\n                    if (cmEntry.length !== 4) {\n                        throw new Error(\n                            'ColorMap entries must contain 4 values'\n                        );\n                    }\n                }\n                this.colorMap = params.colorMap;\n            } else {\n                this.colorMap = [];\n                for (let i = 0; i < 256; i++) {\n                    const val = (255 - i) / 256;\n                    this.colorMap.push([val, val, val, 1]);\n                }\n            }\n            this.width = drawer.width;\n            this.pixelRatio = this.params.pixelRatio || ws.params.pixelRatio;\n            this.fftSamples =\n                this.params.fftSamples || ws.params.fftSamples || 512;\n            this.height = this.params.height || this.fftSamples / 2;\n            this.noverlap = params.noverlap;\n            this.windowFunc = params.windowFunc;\n            this.alpha = params.alpha;\n            this.splitChannels = params.splitChannels;\n            this.channels = this.splitChannels ? ws.backend.buffer.numberOfChannels : 1;\n\n            // Getting file's original samplerate is difficult(#1248).\n            // So set 12kHz default to render like wavesurfer.js 5.x.\n            this.frequencyMin = params.frequencyMin || 0;\n            this.frequencyMax = params.frequencyMax || 12000;\n\n            this.createWrapper();\n            this.createCanvas();\n            this.render();\n\n            drawer.wrapper.addEventListener('scroll', this._onScroll);\n            ws.on('redraw', this._onRender);\n        };\n    }\n\n    init() {\n        // Check if wavesurfer is ready\n        if (this.wavesurfer.isReady) {\n            this._onReady();\n        } else {\n            this.wavesurfer.once('ready', this._onReady);\n        }\n    }\n\n    destroy() {\n        this.unAll();\n        this.wavesurfer.un('ready', this._onReady);\n        this.wavesurfer.un('redraw', this._onRender);\n        this.drawer && this.drawer.wrapper.removeEventListener('scroll', this._onScroll);\n        this.wavesurfer = null;\n        this.util = null;\n        this.params = null;\n        if (this.wrapper) {\n            this.wrapper.removeEventListener('click', this._onWrapperClick);\n            this.wrapper.parentNode.removeChild(this.wrapper);\n            this.wrapper = null;\n        }\n    }\n\n    createWrapper() {\n        const prevSpectrogram = this.container.querySelector('spectrogram');\n        if (prevSpectrogram) {\n            this.container.removeChild(prevSpectrogram);\n        }\n        const wsParams = this.wavesurfer.params;\n        this.wrapper = document.createElement('spectrogram');\n        // if labels are active\n        if (this.params.labels) {\n            const labelsEl = (this.labelsEl = document.createElement('canvas'));\n            labelsEl.classList.add('spec-labels');\n            this.drawer.style(labelsEl, {\n                position: 'absolute',\n                zIndex: 9,\n                height: `${this.height * this.channels}px`,\n                width: `55px`\n            });\n            this.wrapper.appendChild(labelsEl);\n            this.loadLabels(\n                'rgba(68,68,68,0.5)',\n                '12px',\n                '10px',\n                '',\n                '#fff',\n                '#f7f7f7',\n                'center',\n                '#specLabels'\n            );\n        }\n\n        this.drawer.style(this.wrapper, {\n            display: 'block',\n            position: 'relative',\n            userSelect: 'none',\n            webkitUserSelect: 'none',\n            height: `${this.height * this.channels}px`\n        });\n\n        if (wsParams.fillParent || wsParams.scrollParent) {\n            this.drawer.style(this.wrapper, {\n                width: '100%',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            });\n        }\n        this.container.appendChild(this.wrapper);\n\n        this.wrapper.addEventListener('click', this._onWrapperClick);\n    }\n\n    _wrapperClickHandler(event) {\n        event.preventDefault();\n        const relX = 'offsetX' in event ? event.offsetX : event.layerX;\n        this.fireEvent('click', relX / this.width || 0);\n    }\n\n    createCanvas() {\n        const canvas = (this.canvas = this.wrapper.appendChild(\n            document.createElement('canvas')\n        ));\n\n        this.spectrCc = canvas.getContext('2d');\n\n        this.util.style(canvas, {\n            position: 'absolute',\n            zIndex: 4\n        });\n    }\n\n    render() {\n        this.updateCanvasStyle();\n\n        if (this.frequenciesDataUrl) {\n            this.loadFrequenciesData(this.frequenciesDataUrl);\n        } else {\n            this.getFrequencies(this.drawSpectrogram);\n        }\n    }\n\n    updateCanvasStyle() {\n        const width = Math.round(this.width / this.pixelRatio) + 'px';\n        this.canvas.width = this.width;\n        this.canvas.height = this.fftSamples / 2 * this.channels;\n        this.canvas.style.width = width;\n        this.canvas.style.height = this.height + 'px';\n    }\n\n    drawSpectrogram(frequenciesData, my) {\n        if (!isNaN(frequenciesData[0][0])) { // data is 1ch [sample, freq] format\n            // to [channel, sample, freq] format\n            frequenciesData = [frequenciesData];\n        }\n\n        const spectrCc = my.spectrCc;\n        const height = my.fftSamples / 2;\n        const width = my.width;\n        const freqFrom = my.buffer.sampleRate / 2;\n        const freqMin = my.frequencyMin;\n        const freqMax = my.frequencyMax;\n\n        if (!spectrCc) {\n            return;\n        }\n\n        for (let c = 0; c < frequenciesData.length; c++) { // for each channel\n            const pixels = my.resample(frequenciesData[c]);\n            const imageData = new ImageData(width, height);\n\n            for (let i = 0; i < pixels.length; i++) {\n                for (let j = 0; j < pixels[i].length; j++) {\n                    const colorMap = my.colorMap[pixels[i][j]];\n                    const redIndex = ((height - j) * width + i) * 4;\n                    imageData.data[redIndex] = colorMap[0] * 255;\n                    imageData.data[redIndex + 1] = colorMap[1] * 255;\n                    imageData.data[redIndex + 2] = colorMap[2] * 255;\n                    imageData.data[redIndex + 3] = colorMap[3] * 255;\n                }\n            }\n\n            // scale and stack spectrograms\n            createImageBitmap(imageData).then(renderer =>\n                spectrCc.drawImage(renderer,\n                    0, height * (1 - freqMax / freqFrom), // source x, y\n                    width, height * (freqMax - freqMin) / freqFrom, // source width, height\n                    0, height * c, // destination x, y\n                    width, height // destination width, height\n                )\n            );\n        }\n    }\n\n    getFrequencies(callback) {\n        const fftSamples = this.fftSamples;\n        const buffer = (this.buffer = this.wavesurfer.backend.buffer);\n        const channels = this.channels;\n\n        if (!buffer) {\n            this.fireEvent('error', 'Web Audio buffer is not available');\n            return;\n        }\n\n        // This may differ from file samplerate. Browser resamples audio.\n        const sampleRate = buffer.sampleRate;\n        const frequencies = [];\n\n        let noverlap = this.noverlap;\n        if (!noverlap) {\n            const uniqueSamplesPerPx = buffer.length / this.canvas.width;\n            noverlap = Math.max(0, Math.round(fftSamples - uniqueSamplesPerPx));\n        }\n\n        const fft = new FFT(\n            fftSamples,\n            sampleRate,\n            this.windowFunc,\n            this.alpha\n        );\n\n        for (let c = 0; c < channels; c++) { // for each channel\n            const channelData = buffer.getChannelData(c);\n            const channelFreq = [];\n            let currentOffset = 0;\n\n            while (currentOffset + fftSamples < channelData.length) {\n                const segment = channelData.slice(\n                    currentOffset,\n                    currentOffset + fftSamples\n                );\n                const spectrum = fft.calculateSpectrum(segment);\n                const array = new Uint8Array(fftSamples / 2);\n                let j;\n                for (j = 0; j < fftSamples / 2; j++) {\n                    array[j] = Math.max(-255, Math.log10(spectrum[j]) * 45);\n                }\n                channelFreq.push(array);\n                // channelFreq: [sample, freq]\n\n                currentOffset += fftSamples - noverlap;\n            }\n            frequencies.push(channelFreq);\n            // frequencies: [channel, sample, freq]\n        }\n        callback(frequencies, this);\n    }\n\n    loadFrequenciesData(url) {\n        const request = this.util.fetchFile({ url: url });\n\n        request.on('success', data =>\n            this.drawSpectrogram(JSON.parse(data), this)\n        );\n        request.on('error', e => this.fireEvent('error', e));\n\n        return request;\n    }\n\n    freqType(freq) {\n        return freq >= 1000 ? (freq / 1000).toFixed(1) : Math.round(freq);\n    }\n\n    unitType(freq) {\n        return freq >= 1000 ? 'KHz' : 'Hz';\n    }\n\n    loadLabels(\n        bgFill,\n        fontSizeFreq,\n        fontSizeUnit,\n        fontType,\n        textColorFreq,\n        textColorUnit,\n        textAlign,\n        container\n    ) {\n        const frequenciesHeight = this.height;\n        bgFill = bgFill || 'rgba(68,68,68,0)';\n        fontSizeFreq = fontSizeFreq || '12px';\n        fontSizeUnit = fontSizeUnit || '10px';\n        fontType = fontType || 'Helvetica';\n        textColorFreq = textColorFreq || '#fff';\n        textColorUnit = textColorUnit || '#fff';\n        textAlign = textAlign || 'center';\n        container = container || '#specLabels';\n        const bgWidth = 55;\n        const getMaxY = frequenciesHeight || 512;\n        const labelIndex = 5 * (getMaxY / 256);\n        const freqStart = this.frequencyMin;\n        const step = (this.frequencyMax - freqStart) / labelIndex;\n\n        // prepare canvas element for labels\n        const ctx = this.labelsEl.getContext('2d');\n        const dispScale = window.devicePixelRatio;\n        this.labelsEl.height = this.height * this.channels * dispScale;\n        this.labelsEl.width = bgWidth * dispScale;\n        ctx.scale(dispScale, dispScale);\n\n        if (!ctx) {\n            return;\n        }\n\n        for (let c = 0; c < this.channels; c++) { // for each channel\n            // fill background\n            ctx.fillStyle = bgFill;\n            ctx.fillRect(0, c * getMaxY, bgWidth, (1 + c) * getMaxY);\n            ctx.fill();\n            let i;\n\n            // render labels\n            for (i = 0; i <= labelIndex; i++) {\n                ctx.textAlign = textAlign;\n                ctx.textBaseline = 'middle';\n\n                const freq = freqStart + step * i;\n                const label = this.freqType(freq);\n                const units = this.unitType(freq);\n                const yLabelOffset = 2;\n                const x = 16;\n                let y;\n\n                if (i == 0) {\n                    y = (1 + c) * getMaxY + i - 10;\n                    // unit label\n                    ctx.fillStyle = textColorUnit;\n                    ctx.font = fontSizeUnit + ' ' + fontType;\n                    ctx.fillText(units, x + 24, y);\n                    // freq label\n                    ctx.fillStyle = textColorFreq;\n                    ctx.font = fontSizeFreq + ' ' + fontType;\n                    ctx.fillText(label, x, y);\n                } else {\n                    y = (1 + c) * getMaxY - i * 50 + yLabelOffset;\n                    // unit label\n                    ctx.fillStyle = textColorUnit;\n                    ctx.font = fontSizeUnit + ' ' + fontType;\n                    ctx.fillText(units, x + 24, y);\n                    // freq label\n                    ctx.fillStyle = textColorFreq;\n                    ctx.font = fontSizeFreq + ' ' + fontType;\n                    ctx.fillText(label, x, y);\n                }\n            }\n        }\n    }\n\n    updateScroll(e) {\n        if (this.wrapper) {\n            this.wrapper.scrollLeft = e.target.scrollLeft;\n        }\n    }\n\n    resample(oldMatrix) {\n        const columnsNumber = this.width;\n        const newMatrix = [];\n\n        const oldPiece = 1 / oldMatrix.length;\n        const newPiece = 1 / columnsNumber;\n        let i;\n\n        for (i = 0; i < columnsNumber; i++) {\n            const column = new Array(oldMatrix[0].length);\n            let j;\n\n            for (j = 0; j < oldMatrix.length; j++) {\n                const oldStart = j * oldPiece;\n                const oldEnd = oldStart + oldPiece;\n                const newStart = i * newPiece;\n                const newEnd = newStart + newPiece;\n\n                const overlap =\n                    oldEnd <= newStart || newEnd <= oldStart\n                        ? 0\n                        : Math.min(\n                            Math.max(oldEnd, newStart),\n                            Math.max(newEnd, oldStart)\n                        ) -\n                        Math.max(\n                            Math.min(oldEnd, newStart),\n                            Math.min(newEnd, oldStart)\n                        );\n                let k;\n                /* eslint-disable max-depth */\n                if (overlap > 0) {\n                    for (k = 0; k < oldMatrix[0].length; k++) {\n                        if (column[k] == null) {\n                            column[k] = 0;\n                        }\n                        column[k] += (overlap / newPiece) * oldMatrix[j][k];\n                    }\n                }\n                /* eslint-enable max-depth */\n            }\n\n            const intColumn = new Uint8Array(oldMatrix[0].length);\n            let m;\n\n            for (m = 0; m < oldMatrix[0].length; m++) {\n                intColumn[m] = column[m];\n            }\n\n            newMatrix.push(intColumn);\n        }\n\n        return newMatrix;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}